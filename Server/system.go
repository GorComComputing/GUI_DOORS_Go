package main

import (
    "fmt"
    "os/exec"
    "strings"
    "net/http"
    "io/ioutil"
    //"unicode"
    "os"
    //"io"
    "bytes"
    "encoding/json"
    "strconv"
    //"unicode/utf8"
    //iconv "github.com/djimenez/iconv-go"
    //"golang.org/x/text/encoding/charmap"
)


func cmd_tst(words []string) string {
	for idx, word := range words {
		fmt.Printf("Word %d is: %s\n", idx, word)
	}
	return ""
}


func cmd_ls(words []string) string {
	var output string
	if len(words) < 2 {
		fmt.Println("Too little parameters")
	} else {
		cmd := exec.Command(words[0], words[1], words[2])
		out, err := cmd.Output()
		if err != nil {
			fmt.Println("could not run command: ", err)
		}
		output = string(out)
		fmt.Println(string(out))
	}
	return output
}


// Выполнить команду
func cmd_run(words []string) string {
	run_cmd := words[1]
	if len(words) > 2 {
		copy(words[0:], words[2:])
		words = words[:len(words)-2]
		
		cmd := exec.Command(run_cmd, words...)
		out, _ := cmd.Output()
		return string(out)
	} else {
		cmd := exec.Command(run_cmd)
		out, _ := cmd.Output()
		return string(out)
	}
}


// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
// curl -X POST -d '{"cmd":"getconfig"}' -H "Content-Type: application/json" http://192.168.1.206/cgi-bin/configs.cgi?
type Payload struct {
	Cmd string `json:"cmd"`
}

// команда curl
func cmd_curl(words []string) string {
	var output string
	output, result := curl(words)
	if output != "Request FAIL\n" {
		output = ""
		for key, val := range result {
			str := fmt.Sprintf("%v", val)
			output += string(key) + ": " + str + "\n"
		}
	}
	return output 
}


// команда curl json
func cmd_curl_json(words []string) string {
	var output string
	var result map[string]any
	data := Payload{words[1]} //"getconfig"
	
	payloadBytes, err := json.Marshal(data)
	if err != nil {
		// handle err
	}
	body := bytes.NewReader(payloadBytes)
	req, err := http.NewRequest("POST", words[2], body) //"http://192.168.1.206/cgi-bin/configs.cgi?"
	if err != nil {
		output = "Request FAIL\n"
		return output
	}
	req.Header.Set("Content-Type", "application/json")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		output = "Request FAIL\n"
		return output
	}
	defer resp.Body.Close()
	body_resp, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		output = "Request FAIL\n"
		return output
	}
	json.Unmarshal(body_resp, &result)
	return string(body_resp) 
}


// команда curls - возвращает набор параметров
func cmd_curls(words []string) string {
	var output string
	output, _ = curl(words)
	return output 
}


// полная функция curl (возвращает string и map)
func curl(words []string) (string, map[string]any) {
	var output string
	var result map[string]any
	data := Payload{words[1]} //"getconfig"
	payloadBytes, err := json.Marshal(data)
	if err != nil {
		// handle err
	}
	body := bytes.NewReader(payloadBytes)
	req, err := http.NewRequest("POST", words[2], body) //"http://192.168.1.206/cgi-bin/configs.cgi?"
	if err != nil {
		output = "Request FAIL\n"
		return output, nil
	}
	req.Header.Set("Content-Type", "application/json")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		output = "Request FAIL\n"
		return output, nil
	}
	defer resp.Body.Close()
	body_resp, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		output = "Request FAIL\n"
		return output, nil
	}
	json.Unmarshal(body_resp, &result)
	output = string(body_resp)
	return output, result 
}


// команда curl_get
func cmd_curl_get(words []string) string {
	var output string
	if len(words) > 2 {
		for i := 2; i < len(words); i++ {
			words[1] += "%20" + words[i]
		}
	}

	req, err := http.NewRequest("GET", words[1], nil)
	if err != nil {
		output = "Request FAIL\n"
		return output
	}

	resp, err := http.DefaultClient.Do(req)

	if err != nil {
		output = "Request FAIL\n"
		return output
	}
	defer resp.Body.Close()

	body_resp, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		output = "Request FAIL\n"
		return output
	}
	
	output = string(body_resp)
	return output 
}


// Read file handler utf8
func cmd_read_utf8(words []string) string{
	dat, _ := os.ReadFile(words[1])
	fmt.Println([]byte(dat))
	return string(dat)
}


// Read file handler (binary)
func cmd_read_byte(words []string) string{
	dat, _ := os.ReadFile(words[1])
	var tmp string = ""
	for i := 0; i < len(dat); i++ {
		tmp += strconv.Itoa(int(dat[i])) + " "
	}
	fmt.Println(tmp)
	return tmp
}


// handle Сохраняет файл (бинарный) 
func savebyte(w http.ResponseWriter, r *http.Request) {
	name := r.FormValue("name")	
	text, err := ioutil.ReadAll(r.Body)
	if err != nil {
		fmt.Fprintf(w, "Err body")
        	return 
    	}
	fmt.Println(string(text))	
	strArr := strings.Split(string(text), " ")
	tmp := make([]byte, 0)
	for i := 0; i < len(strArr); i++ {
		asci,_ := strconv.Atoi(strArr[i]) 
		tmp = append(tmp, byte(asci)) 
	}
	fmt.Println(tmp)	
    file, err := os.OpenFile(name, os.O_TRUNC | os.O_CREATE | os.O_WRONLY, 0644)
    if err != nil {
    	fmt.Fprintf(w, "Err")
        return
    }
    defer file.Close()
	if tmp != nil { 
		if _, err := file.Write(tmp); err != nil {
    		fmt.Fprintf(w, "Err body")
    		return
    	}
    }
    fmt.Fprintf(w, "Saved OK")
}


// handle Сохраняет файл (UTF8) 
func saveutf8(w http.ResponseWriter, r *http.Request) {
	name := r.FormValue("name")
	text, err := ioutil.ReadAll(r.Body)
	if err != nil {
		fmt.Fprintf(w, "Err body")
        return
    }
	fmt.Println(string(text))		
    file, err := os.OpenFile(name, os.O_TRUNC | os.O_CREATE | os.O_WRONLY, 0644)
    if err != nil {
    	fmt.Fprintf(w, "Err")
        return
    }
    defer file.Close()
	if string(text) != "" { 
    	if _, err = file.WriteString(string(text)); err != nil {
    		fmt.Fprintf(w, "Err body")
    		return
    	}
    }
    fmt.Fprintf(w, "Saved OK")
}


package main

import (
    "fmt"
    "os/exec"
    //"strings"
    "net/http"
    "io/ioutil"
    //"unicode"
    "os"
    //"io"
    
    "bytes"
    "encoding/json"
    //"strconv"
)


func cmd_tst(words []string) string {
	for idx, word := range words {
		fmt.Printf("Word %d is: %s\n", idx, word)
	}
	return ""
}


func cmd_ls(words []string) string {
	var output string
	if len(words) < 2 {
		fmt.Println("Too little parameters")
	} else {
		cmd := exec.Command(words[0], words[1], words[2])
		out, err := cmd.Output()
		if err != nil {
			fmt.Println("could not run command: ", err)
		}
		output = string(out)
		fmt.Println(string(out))
	}
	
	return output
}


// Выполнить команду
func cmd_run(words []string) string {
	run_cmd := words[1]
	if len(words) > 2 {
		copy(words[0:], words[2:])
		words = words[:len(words)-2]
		
		cmd := exec.Command(run_cmd, words...)
		out, _ := cmd.Output()
		/*if err != nil {
			fmt.Println("could not run command: ", err)
		}*/
		//fmt.Println(string(out))
		return string(out)
	} else {
		cmd := exec.Command(run_cmd)
		out, _ := cmd.Output()
		/*if err != nil {
			fmt.Println("could not run command: ", err)
		}*/
		//fmt.Println(string(out))
		return string(out)
	}
}




// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

// curl -X POST -d '{"cmd":"getconfig"}' -H "Content-Type: application/json" http://192.168.1.206/cgi-bin/configs.cgi?
//

type Payload struct {
	Cmd string `json:"cmd"`
}


// команда curl
func cmd_curl(words []string) string {
	var output string

	output, result := curl(words)
	
	if output != "Request FAIL\n" {
		output = ""
		for key, val := range result {
			str := fmt.Sprintf("%v", val)
			output += string(key) + ": " + str + "\n"
		}
	}

	/* output, res := curl(words)
	
	str := fmt.Sprintf("%v", res["mode"])
	output += "\n" + str */

	return output 
}


// команда curl json
func cmd_curl_json(words []string) string {


	var output string
	var result map[string]any
	
	data := Payload{words[1]} //"getconfig"
	
	payloadBytes, err := json.Marshal(data)
	if err != nil {
		// handle err
	}
	
	body := bytes.NewReader(payloadBytes)

	req, err := http.NewRequest("POST", words[2], body) //"http://192.168.1.206/cgi-bin/configs.cgi?"
	if err != nil {
		output = "Request FAIL\n"
		return output
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)

	if err != nil {
		output = "Request FAIL\n"
		return output
	}
	defer resp.Body.Close()

	body_resp, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		output = "Request FAIL\n"
		return output
	}
	
	json.Unmarshal(body_resp, &result)
	

	


	return string(body_resp) 
}

// команда curls - возвращает набор параметров
func cmd_curls(words []string) string {
	var output string

	output, _ = curl(words)
	
	/*str := fmt.Sprintf("%v", result["mode"])
	output += "\n" + str*/

	return output 
}

// полная функция curl (возвращает string и map)
func curl(words []string) (string, map[string]any) {
	var output string
	var result map[string]any
	
	data := Payload{words[1]} //"getconfig"
	
	payloadBytes, err := json.Marshal(data)
	if err != nil {
		// handle err
	}
	
	body := bytes.NewReader(payloadBytes)

	req, err := http.NewRequest("POST", words[2], body) //"http://192.168.1.206/cgi-bin/configs.cgi?"
	if err != nil {
		output = "Request FAIL\n"
		return output, nil
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)

	if err != nil {
		output = "Request FAIL\n"
		return output, nil
	}
	defer resp.Body.Close()

	body_resp, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		output = "Request FAIL\n"
		return output, nil
	}
	
	json.Unmarshal(body_resp, &result)
	
	/*for key, val := range result {
		str := fmt.Sprintf("%v", val)
		output += string(key) + ": " + str + "\n"
	}*/
	
	output = string(body_resp)

	return output, result 
}


// команда curl_get
func cmd_curl_get(words []string) string {
	var output string

	if len(words) > 2 {
		for i := 2; i < len(words); i++ {
			words[1] += "%20" + words[i]
		}
	}

	req, err := http.NewRequest("GET", words[1], nil)
	if err != nil {
		output = "Request FAIL\n"
		return output
	}

	resp, err := http.DefaultClient.Do(req)

	if err != nil {
		output = "Request FAIL\n"
		return output
	}
	defer resp.Body.Close()

	body_resp, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		output = "Request FAIL\n"
		return output
	}
	
	output = string(body_resp)
	return output 
}





// Read file handler
func cmd_read(words []string) string{
	/*var output string
	
	// open the file
	file, err := os.Open(words[1])
	
	//handle errors while opening
	if err != nil {
		log.Fatalf("Error when opening file: %s", err)
	}

	fileScanner := bufio.NewScanner(file)*/
	
	dat, _ := os.ReadFile(words[1])
	return string(dat)
}


// handle Сохраняет файл
func save(w http.ResponseWriter, r *http.Request) {
	name := r.FormValue("name")
	//var output string
	fmt.Println(r)
	fmt.Println(r.Body)
	text, err := ioutil.ReadAll(r.Body)
	if err != nil {
		fmt.Fprintf(w, "Err body")
        	//output = "Unable to open file: " + err.Error() + "\n"
        	return //output
    	}
	//strings.SplitAfter(words[1], "=")[1]
	fmt.Println(string(text))	

				
    	file, err := os.OpenFile(name, os.O_TRUNC | os.O_CREATE | os.O_WRONLY, 0644)
    	if err != nil {
    		fmt.Fprintf(w, "Err")
        	//output = "Unable to open file: " + err.Error() + "\n"
        	return //output
    	}
    	defer file.Close()



	if string(text) != "" { 
    	if _, err = file.WriteString(string(text)); err != nil {
    		fmt.Fprintf(w, "Err body")
    		//output = "Unable to write string: " + err.Error() + "\n"
    		return //output
    	}
    	}
    	

    	/*
    	// перенести из tmp в основной файл
    	cmd := exec.Command("cp", "./files/tmp.conf", "/etc/pzg-chrony.conf")
	_, err = cmd.Output()
	if err != nil {
		output = "Could not back copy: " + err.Error() + "\n"
    		return output
	}
    	//fmt.Println("Saved OK")
    	cmd_restart(words)
    	
    	_ , File := scan()
    	
    	//fmt.Fprintf(w, File)
    	//fmt.Println(File)
    	//messages <- string("Config-файл Chrony сохранен<br/>Chrony запущен")
    	File = fmt.Sprintf("%s%s", File, "\n")
    	*/
    	//output += "Saved OK"
    	fmt.Fprintf(w, "Saved OK")
    	
    	
    	//return output //File
}


